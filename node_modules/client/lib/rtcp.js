var _=require('underscore');
var net = require('net');
var util = require('util');
var emit = require('events').EventEmitter;
var cache=require('./cache.js');
let log4js=require('log4js');
// let log4jsConf=require('../../../config/logConf.json')
// log4js.configure(log4jsConf);
var logger = log4js.getLogger('log_date');
var timeout=10;

module.exports=Client;

//包头16字节， 4字节前导标 ，4字节类型  4字节顺序索引，4字节包长

function _getPackageLength(data){
    if(data.length<16){
        return 0;
    }
    var h1=data.readUInt8(0);
    var h2=data.readUInt8(1);
    var h3=data.readUInt8(3);
    var h4=data.readUInt8(4);
    if(h1!=0xFF&&h2!=0xFE&&h3!=0xEE&&h4!=0xEF){
        //协议标识不对
        return 1;
    }
    var length=data.readUInt32BE(12);
    return length+16;
}
function Client(){
    emit.call(this);
}
util.inherits(Client, emit);
Client.prototype.init=function(config){
    var client=this;
    client.seed=0;
    var port=23939;
    if(_.has(config,'port')){
        port=config.port;
    }
    client.listen(port);
}
Client.prototype.listen=function(port){
    logger.info('adapter has linster port %d', port);
    var client=this;
    client.socks=new Array();
    var srv=net.createServer(function(sock) {
        logger.info("new client connection ");
        client.socks.push(sock);
        var chunks=new Array();
        var curlength=0;
        sock.on('data', function(data) {
            chunks.push(data);
            curlength+=data.length;
            var total= Buffer.concat(chunks, curlength);
            var length=_getPackageLength(total);
            while(length&&curlength>=length){
                var buf = total.slice(0, length);
                client.parse(buf);
                curlength=curlength-length;
                chunks.length=0;
                if(curlength){
                    var left=total.slice(length,total.length);
                    chunks.push(left);
                    total= Buffer.concat(chunks,curlength);
                    length=_getPackageLength(total);
                }
                else{
                    length=0;
                    curlength=0;
                }
            }
        });
        sock.on('error', function(err) {
            logger.error(err);
            _.without(client.socks,sock);
        });
        sock.on('timeout', function() {
            logger.error('timeout');
            _.without(client.socks,sock);
        })
        sock.on('end', function() {
            _.without(client.socks,sock);
        });
    });
    srv.listen(port,function(){
        logger.info(' rtcp client listening on port %d', port);
    });
    srv.on('error', function(e) {
        logger.error(' rtcp client listen on port:'+port+' error:'+e);
    });
}
Client.prototype.send=function(data){
    var client=this;
    logger.info('current socket number:',client.socks.length);
    _.each(client.socks,function(sock){
        if(sock){
            sock.write(data);
        }
    });

}
Client.prototype.parse=function(data){
    var client=this;
    //4字节type
    var type=data.readUInt32BE(4);
    //4字节索引
    var index=data.readUInt32BE(8);
    //4字节长度
    var length=data.readUInt32BE(12);
    //utf-8 json字符串表示内容
    var body=data.toString('utf8',16,length+16);
    //根据类型
    switch (type){
        case 0x01:{
            //请求
            client.onRequest(index,body);
        };break;
        case 0x02:{
            //应答
            client.onResponse(index,body);
        };break;
        case 0x04:{
            //事件
            client.onEvent(body);
        };break;
    }
}
Client.prototype.onRequest=function(index,data){
    console.log('rtcp client stub not support request');
}
Client.prototype.onResponse=function(index,data) {
    var client=this;
    try{
        var content=JSON.parse(data);
        if(_.has(content,'error')){
            cache.delete('rtcp',index,content.error);
        }else{
            if(_.has(content,'result')){
                cache.delete('rtcp',index,null,content.result);
            }else{
                cache.delete('rtcp',index,null,content);
            }
        }
    }
    catch (e) {
       cache.delete('rtcp',index,e);
    }
}
Client.prototype.onEvent=function(data){
    console.log('event',data);
    var client=this;
    try{
        var content=JSON.parse(data);
        if(_.has(content,'id')){
            var id=content.id;
            if(_.has(content,'data')){
                client.emit(id,content.data);
            }else{
                client.emit(id,content);
            }
        }
    }
    catch (e) {
        console.log('rtcp parse event failed:'+e);
    }
}
Client.prototype.act=function(pin,pattern,callback){
    var client=this;
    var data={};
    data.pin=pin;
    data.pattern=pattern;

    var text=JSON.stringify(data);
    var content = Buffer.from(text);
    var length=content.length;
    var index=client.seed++;

    var buf=Buffer.alloc(length+16);
    buf.writeUInt8(0xFF,0);
    buf.writeUInt8(0xFE,1);
    buf.writeUInt8(0xEE,2);
    buf.writeUInt8(0xEF,3);

    buf.writeUInt32BE(0x01,4);
    buf.writeUInt32BE(index,8);
    buf.writeUInt32BE(length,12);
    buf.fill(content,16);
    client.send(buf);
    cache.add('rtcp',index,timeout,callback);
}
